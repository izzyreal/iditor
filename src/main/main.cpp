#include <FL/Fl.H>
#include <FL/Fl_Window.H>

#include "Editor.h"

#include "Globals.h"

#include <cmrc/cmrc.hpp>
#include <string_view>
#include <fstream>

CMRC_DECLARE(iditor);

void write_rc_file_to_run_dir(const std::string& path)
{
  auto fs = cmrc::iditor::get_filesystem();
  auto file = fs.open(path);
  auto data = std::string_view(file.begin(), file.size()).data();

  std::ofstream myfile;
  auto cwd = std::filesystem::current_path();
  myfile.open (cwd.append(path).c_str());
  myfile.write(data, (long) file.size());
  myfile.close();
}

int escKeyConsumer(int event)
{
  if (event == FL_SHORTCUT && Fl::event_key() == FL_Escape)
  {
    return 1;
  }

  return 0;
}

const char* text = "// -*- C++ -*-\n"
                   "//===--------------------------- __config ---------------------------------===//\n"
                   "//\n"
                   "// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n"
                   "// See https://llvm.org/LICENSE.txt for license information.\n"
                   "// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n"
                   "//\n"
                   "//===----------------------------------------------------------------------===//\n"
                   "\n"
                   "#ifndef _LIBCPP_CONFIG\n"
                   "#define _LIBCPP_CONFIG\n"
                   "\n"
                   "#include <__config_site>\n"
                   "\n"
                   "#if defined(_MSC_VER) && !defined(__clang__)\n"
                   "#  if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n"
                   "#    define _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER\n"
                   "#  endif\n"
                   "#endif\n"
                   "\n"
                   "#ifndef _LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER\n"
                   "#pragma GCC system_header\n"
                   "#endif\n"
                   "\n"
                   "#ifdef __cplusplus\n"
                   "\n"
                   "#ifdef __GNUC__\n"
                   "#  define _GNUC_VER (__GNUC__ * 100 + __GNUC_MINOR__)\n"
                   "// The _GNUC_VER_NEW macro better represents the new GCC versioning scheme\n"
                   "// introduced in GCC 5.0.\n"
                   "#  define _GNUC_VER_NEW (_GNUC_VER * 10 + __GNUC_PATCHLEVEL__)\n"
                   "#else\n"
                   "#  define _GNUC_VER 0\n"
                   "#  define _GNUC_VER_NEW 0\n"
                   "#endif\n"
                   "\n"
                   "#define _LIBCPP_VERSION 13000\n"
                   "\n"
                   "#ifndef _LIBCPP_ABI_VERSION\n"
                   "#  define _LIBCPP_ABI_VERSION 1\n"
                   "#endif\n"
                   "\n"
                   "#if __STDC_HOSTED__ == 0\n"
                   "#  define _LIBCPP_FREESTANDING\n"
                   "#endif\n"
                   "\n"
                   "#ifndef _LIBCPP_STD_VER\n"
                   "#  if  __cplusplus <= 201103L\n"
                   "#    define _LIBCPP_STD_VER 11\n"
                   "#  elif __cplusplus <= 201402L\n"
                   "#    define _LIBCPP_STD_VER 14\n"
                   "#  elif __cplusplus <= 201703L\n"
                   "#    define _LIBCPP_STD_VER 17\n"
                   "#  elif __cplusplus <= 202002L\n"
                   "#    define _LIBCPP_STD_VER 20\n"
                   "#  else\n"
                   "#    define _LIBCPP_STD_VER 21  // current year, or date of c++2b ratification\n"
                   "#  endif\n"
                   "#endif // _LIBCPP_STD_VER\n"
                   "\n"
                   "#if defined(__ELF__)\n"
                   "#  define _LIBCPP_OBJECT_FORMAT_ELF   1\n"
                   "#elif defined(__MACH__)\n"
                   "#  define _LIBCPP_OBJECT_FORMAT_MACHO 1\n"
                   "#elif defined(_WIN32)\n"
                   "#  define _LIBCPP_OBJECT_FORMAT_COFF  1\n"
                   "#elif defined(__wasm__)\n"
                   "#  define _LIBCPP_OBJECT_FORMAT_WASM  1\n"
                   "#else\n"
                   "   // ... add new file formats here ...\n"
                   "#endif\n"
                   "\n"
                   "// TODO: This is a hacky way to detect that we're building for RTKit because\n"
                   "//       they don't have a proper tripple. Once they do, use a macro that would\n"
                   "//       be defined by the compiler.\n"
                   "#if __has_include(<RTK_device_methods.h>) && defined(_LIBCPP_HAS_NO_RANDOM_DEVICE) && defined(_LIBCPP_HAS_NO_LOCALIZATION)\n"
                   "# define _LIBCPP_ON_RTKIT\n"
                   "#endif\n"
                   "\n"
                   "// TODO: This is a hacky way to detect that we're building for SEP. We need the\n"
                   "//       compiler to define a macro when we build for that triple instead.\n"
                   "#if defined(_LIBCPP_HAS_NO_RANDOM_DEVICE) && defined(_LIBCPP_HAS_NO_WIDE_CHARACTERS) && !defined(_LIBCPP_ON_RTKIT)\n"
                   "# define _LIBCPP_ON_SEP\n"
                   "#endif\n"
                   "\n"
                   "#if defined(_LIBCPP_ABI_UNSTABLE) || _LIBCPP_ABI_VERSION >= 2\n"
                   "// Change short string representation so that string data starts at offset 0,\n"
                   "// improving its alignment in some cases.\n"
                   "#  define _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n"
                   "// Fix deque iterator type in order to support incomplete types.\n"
                   "#  define _LIBCPP_ABI_INCOMPLETE_TYPES_IN_DEQUE\n"
                   "// Fix undefined behavior in how std::list stores its linked nodes.\n"
                   "#  define _LIBCPP_ABI_LIST_REMOVE_NODE_POINTER_UB\n"
                   "// Fix undefined behavior in  how __tree stores its end and parent nodes.\n"
                   "#  define _LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB\n"
                   "// Fix undefined behavior in how __hash_table stores its pointer types.\n"
                   "#  define _LIBCPP_ABI_FIX_UNORDERED_NODE_POINTER_UB\n"
                   "#  define _LIBCPP_ABI_FORWARD_LIST_REMOVE_NODE_POINTER_UB\n"
                   "#  define _LIBCPP_ABI_FIX_UNORDERED_CONTAINER_SIZE_TYPE\n"
                   "// Don't use a nullptr_t simulation type in C++03 instead using C++11 nullptr\n"
                   "// provided under the alternate keyword __nullptr, which changes the mangling\n"
                   "// of nullptr_t. This option is ABI incompatible with GCC in C++03 mode.\n"
                   "#  define _LIBCPP_ABI_ALWAYS_USE_CXX11_NULLPTR\n"
                   "// Define a key function for `bad_function_call` in the library, to centralize\n"
                   "// its vtable and typeinfo to libc++ rather than having all other libraries\n"
                   "// using that class define their own copies.\n"
                   "#  define _LIBCPP_ABI_BAD_FUNCTION_CALL_KEY_FUNCTION\n"
                   "// Override the default return value of exception::what() for\n"
                   "// bad_function_call::what() with a string that is specific to\n"
                   "// bad_function_call (see http://wg21.link/LWG2233). This is an ABI break\n"
                   "// because it changes the vtable layout of bad_function_call.\n"
                   "#  define _LIBCPP_ABI_BAD_FUNCTION_CALL_GOOD_WHAT_MESSAGE\n"
                   "// Enable optimized version of __do_get_(un)signed which avoids redundant copies.\n"
                   "#  define _LIBCPP_ABI_OPTIMIZED_LOCALE_NUM_GET\n"
                   "// In C++20 and later, don't derive std::plus from std::binary_function,\n"
                   "// nor std::negate from std::unary_function.\n"
                   "#  define _LIBCPP_ABI_NO_BINDER_BASES\n"
                   "// Give reverse_iterator<T> one data member of type T, not two.\n"
                   "// Also, in C++17 and later, don't derive iterator types from std::iterator.\n"
                   "#  define _LIBCPP_ABI_NO_ITERATOR_BASES\n"
                   "// Use the smallest possible integer type to represent the index of the variant.\n"
                   "// Previously libc++ used \"unsigned int\" exclusively.\n"
                   "#  define _LIBCPP_ABI_VARIANT_INDEX_TYPE_OPTIMIZATION\n"
                   "// Unstable attempt to provide a more optimized std::function\n"
                   "#  define _LIBCPP_ABI_OPTIMIZED_FUNCTION\n"
                   "// All the regex constants must be distinct and nonzero.\n"
                   "#  define _LIBCPP_ABI_REGEX_CONSTANTS_NONZERO\n"
                   "// Use raw pointers, not wrapped ones, for std::span's iterator type.\n"
                   "#  define _LIBCPP_ABI_SPAN_POINTER_ITERATORS\n"
                   "// Re-worked external template instantiations for std::string with a focus on\n"
                   "// performance and fast-path inlining.\n"
                   "#  define _LIBCPP_ABI_STRING_OPTIMIZED_EXTERNAL_INSTANTIATION\n"
                   "// Enable clang::trivial_abi on std::unique_ptr.\n"
                   "#  define _LIBCPP_ABI_ENABLE_UNIQUE_PTR_TRIVIAL_ABI\n"
                   "// Enable clang::trivial_abi on std::shared_ptr and std::weak_ptr\n"
                   "#  define _LIBCPP_ABI_ENABLE_SHARED_PTR_TRIVIAL_ABI\n"
                   "#elif _LIBCPP_ABI_VERSION == 1\n"
                   "#  if !defined(_LIBCPP_OBJECT_FORMAT_COFF)\n"
                   "// Enable compiling copies of now inline methods into the dylib to support\n"
                   "// applications compiled against older libraries. This is unnecessary with\n"
                   "// COFF dllexport semantics, since dllexport forces a non-inline definition\n"
                   "// of inline functions to be emitted anyway. Our own non-inline copy would\n"
                   "// conflict with the dllexport-emitted copy, so we disable it.\n"
                   "#    define _LIBCPP_DEPRECATED_ABI_LEGACY_LIBRARY_DEFINITIONS_FOR_INLINE_FUNCTIONS\n"
                   "#  endif\n"
                   "// Feature macros for disabling pre ABI v1 features. All of these options\n"
                   "// are deprecated.\n"
                   "#  if defined(__FreeBSD__)\n"
                   "#    define _LIBCPP_DEPRECATED_ABI_DISABLE_PAIR_TRIVIAL_COPY_CTOR\n"
                   "#  endif\n"
                   "#endif\n"
                   "\n"
                   "#if defined(_LIBCPP_BUILDING_LIBRARY) || defined(_LIBCPP_ABI_UNSTABLE) || _LIBCPP_ABI_VERSION >= 2\n"
                   "// Enable additional explicit instantiations of iostreams components. This\n"
                   "// reduces the number of weak definitions generated in programs that use\n"
                   "// iostreams by providing a single strong definition in the shared library.\n"
                   "# define _LIBCPP_ABI_ENABLE_ADDITIONAL_IOSTREAM_EXPLICIT_INSTANTIATIONS_1\n"
                   "\n"
                   "// Define a key function for `bad_function_call` in the library, to centralize\n"
                   "// its vtable and typeinfo to libc++ rather than having all other libraries\n"
                   "// using that class define their own copies.\n"
                   "#  define _LIBCPP_ABI_BAD_FUNCTION_CALL_KEY_FUNCTION\n"
                   "#endif\n"
                   "\n"
                   "// The additional stream instantiations were added in iOS 15 and aligned.\n"
                   "#if (defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) &&              \\\n"
                   "      __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 120000) ||           \\\n"
                   "    (defined(__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__) &&             \\\n"
                   "      __ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__ >= 150000) ||          \\\n"
                   "    (defined(__ENVIRONMENT_WATCH_OS_VERSION_MIN_REQUIRED__) &&               \\\n"
                   "      __ENVIRONMENT_WATCH_OS_VERSION_MIN_REQUIRED__ >= 80000) ||             \\\n"
                   "    (defined(__ENVIRONMENT_TV_OS_VERSION_MIN_REQUIRED__) &&                  \\\n"
                   "      __ENVIRONMENT_TV_OS_VERSION_MIN_REQUIRED__ >= 150000)\n"
                   "# define _LIBCPP_ABI_ENABLE_ADDITIONAL_IOSTREAM_EXPLICIT_INSTANTIATIONS_1\n"
                   "#endif\n"
                   "\n"
                   "#define _LIBCPP_CONCAT1(_LIBCPP_X,_LIBCPP_Y) _LIBCPP_X##_LIBCPP_Y\n"
                   "#define _LIBCPP_CONCAT(_LIBCPP_X,_LIBCPP_Y) _LIBCPP_CONCAT1(_LIBCPP_X,_LIBCPP_Y)\n"
                   "\n"
                   "#ifndef _LIBCPP_ABI_NAMESPACE\n"
                   "# define _LIBCPP_ABI_NAMESPACE _LIBCPP_CONCAT(__,_LIBCPP_ABI_VERSION)\n"
                   "#endif\n"
                   "\n"
                   "#if __cplusplus < 201103L\n"
                   "#define _LIBCPP_CXX03_LANG\n"
                   "#endif\n"
                   "\n"
                   "#ifndef __has_attribute\n"
                   "#define __has_attribute(__x) 0\n"
                   "#endif\n"
                   "\n"
                   "#ifndef __has_builtin\n"
                   "#define __has_builtin(__x) 0\n"
                   "#endif\n"
                   "\n"
                   "#ifndef __has_extension\n"
                   "#define __has_extension(__x) 0\n"
                   "#endif\n"
                   "\n"
                   "#ifndef __has_feature\n"
                   "#define __has_feature(__x) 0\n"
                   "#endif\n"
                   "\n"
                   "#ifndef __has_cpp_attribute\n"
                   "#define __has_cpp_attribute(__x) 0\n"
                   "#endif\n"
                   "\n"
                   "// '__is_identifier' returns '0' if '__x' is a reserved identifier provided by\n"
                   "// the compiler and '1' otherwise.\n"
                   "#ifndef __is_identifier\n"
                   "#define __is_identifier(__x) 1\n"
                   "#endif\n"
                   "\n"
                   "#ifndef __has_declspec_attribute\n"
                   "#define __has_declspec_attribute(__x) 0\n"
                   "#endif\n"
                   "\n"
                   "#define __has_keyword(__x) !(__is_identifier(__x))\n"
                   "\n"
                   "#ifndef __has_include\n"
                   "#define __has_include(...) 0\n"
                   "#endif\n"
                   "\n"
                   "#if defined(__apple_build_version__)\n"
                   "#  define _LIBCPP_COMPILER_CLANG_BASED\n"
                   "#  define _LIBCPP_APPLE_CLANG_VER (__apple_build_version__ / 10000)\n"
                   "#elif defined(__clang__)\n"
                   "#  define _LIBCPP_COMPILER_CLANG_BASED\n"
                   "#  define _LIBCPP_CLANG_VER (__clang_major__ * 100 + __clang_minor__)\n"
                   "#elif defined(__GNUC__)\n"
                   "#  define _LIBCPP_COMPILER_GCC\n"
                   "#elif defined(_MSC_VER)\n"
                   "#  define _LIBCPP_COMPILER_MSVC\n"
                   "#elif defined(__IBMCPP__)\n"
                   "#  define _LIBCPP_COMPILER_IBM\n"
                   "#endif\n"
                   "\n"
                   "#if defined(_LIBCPP_COMPILER_GCC) && __cplusplus < 201103L\n"
                   "#error \"libc++ does not support using GCC with C++03. Please enable C++11\"\n"
                   "#endif\n"
                   "\n"
                   "// FIXME: ABI detection should be done via compiler builtin macros. This\n"
                   "// is just a placeholder until Clang implements such macros. For now assume\n"
                   "// that Windows compilers pretending to be MSVC++ target the Microsoft ABI,\n"
                   "// and allow the user to explicitly specify the ABI to handle cases where this\n"
                   "// heuristic falls short.\n"
                   "#if defined(_LIBCPP_ABI_FORCE_ITANIUM) && defined(_LIBCPP_ABI_FORCE_MICROSOFT)\n"
                   "#  error \"Only one of _LIBCPP_ABI_FORCE_ITANIUM and _LIBCPP_ABI_FORCE_MICROSOFT can be defined\"\n"
                   "#elif defined(_LIBCPP_ABI_FORCE_ITANIUM)\n"
                   "#  define _LIBCPP_ABI_ITANIUM\n"
                   "#elif defined(_LIBCPP_ABI_FORCE_MICROSOFT)\n"
                   "#  define _LIBCPP_ABI_MICROSOFT\n"
                   "#else\n"
                   "#  if defined(_WIN32) && defined(_MSC_VER)\n"
                   "#    define _LIBCPP_ABI_MICROSOFT\n"
                   "#  else\n"
                   "#    define _LIBCPP_ABI_ITANIUM\n"
                   "#  endif\n"
                   "#endif\n"
                   "\n"
                   "#if defined(_LIBCPP_ABI_MICROSOFT) && !defined(_LIBCPP_NO_VCRUNTIME)\n"
                   "# define _LIBCPP_ABI_VCRUNTIME\n"
                   "#endif\n"
                   "\n"
                   "// Need to detect which libc we're using if we're on Linux.\n"
                   "#if defined(__linux__)\n"
                   "#  include <features.h>\n"
                   "#  if defined(__GLIBC_PREREQ)\n"
                   "#    define _LIBCPP_GLIBC_PREREQ(a, b) __GLIBC_PREREQ(a, b)\n"
                   "#  else\n"
                   "#    define _LIBCPP_GLIBC_PREREQ(a, b) 0\n"
                   "#  endif // defined(__GLIBC_PREREQ)\n"
                   "#endif // defined(__linux__)\n"
                   "\n"
                   "#ifdef __LITTLE_ENDIAN__\n"
                   "#  if __LITTLE_ENDIAN__\n"
                   "#    define _LIBCPP_LITTLE_ENDIAN\n"
                   "#  endif  // __LITTLE_ENDIAN__\n"
                   "#endif // __LITTLE_ENDIAN__\n"
                   "\n"
                   "#ifdef __BIG_ENDIAN__\n"
                   "#  if __BIG_ENDIAN__\n"
                   "#    define _LIBCPP_BIG_ENDIAN\n"
                   "#  endif  // __BIG_ENDIAN__\n"
                   "#endif // __BIG_ENDIAN__\n"
                   "\n"
                   "#ifdef __BYTE_ORDER__\n"
                   "#  if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n"
                   "#    define _LIBCPP_LITTLE_ENDIAN\n"
                   "#  elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n"
                   "#    define _LIBCPP_BIG_ENDIAN\n"
                   "#  endif // __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n"
                   "#endif // __BYTE_ORDER__\n"
                   "\n"
                   "#ifdef __FreeBSD__\n"
                   "#  include <sys/endian.h>\n"
                   "#  include <osreldate.h>\n"
                   "#  if _BYTE_ORDER == _LITTLE_ENDIAN\n"
                   "#    define _LIBCPP_LITTLE_ENDIAN\n"
                   "#  else  // _BYTE_ORDER == _LITTLE_ENDIAN\n"
                   "#    define _LIBCPP_BIG_ENDIAN\n"
                   "#  endif  // _BYTE_ORDER == _LITTLE_ENDIAN\n"
                   "#  ifndef __LONG_LONG_SUPPORTED\n"
                   "#    define _LIBCPP_HAS_NO_LONG_LONG\n"
                   "#  endif  // __LONG_LONG_SUPPORTED\n"
                   "#endif // __FreeBSD__\n"
                   "\n"
                   "#if defined(__NetBSD__) || defined(__OpenBSD__)\n"
                   "#  include <sys/endian.h>\n"
                   "#  if _BYTE_ORDER == _LITTLE_ENDIAN\n"
                   "#    define _LIBCPP_LITTLE_ENDIAN\n"
                   "#  else  // _BYTE_ORDER == _LITTLE_ENDIAN\n"
                   "#    define _LIBCPP_BIG_ENDIAN\n"
                   "#  endif  // _BYTE_ORDER == _LITTLE_ENDIAN\n"
                   "#endif // defined(__NetBSD__) || defined(__OpenBSD__)\n"
                   "\n"
                   "#if defined(_WIN32)\n"
                   "#  define _LIBCPP_WIN32API\n"
                   "#  define _LIBCPP_LITTLE_ENDIAN\n"
                   "#  define _LIBCPP_SHORT_WCHAR   1\n"
                   "// Both MinGW and native MSVC provide a \"MSVC\"-like environment\n"
                   "#  define _LIBCPP_MSVCRT_LIKE\n"
                   "// If mingw not explicitly detected, assume using MS C runtime only if\n"
                   "// a MS compatibility version is specified.\n"
                   "#  if defined(_MSC_VER) && !defined(__MINGW32__)\n"
                   "#    define _LIBCPP_MSVCRT // Using Microsoft's C Runtime library\n"
                   "#  endif\n"
                   "#  if (defined(_M_AMD64) || defined(__x86_64__)) || (defined(_M_ARM) || defined(__arm__))\n"
                   "#    define _LIBCPP_HAS_BITSCAN64\n"
                   "#  endif\n"
                   "#  define _LIBCPP_HAS_OPEN_WITH_WCHAR\n"
                   "#  if defined(_LIBCPP_MSVCRT)\n"
                   "#    define _LIBCPP_HAS_QUICK_EXIT\n"
                   "#  endif\n"
                   "\n"
                   "// Some CRT APIs are unavailable to store apps\n"
                   "#  if defined(WINAPI_FAMILY)\n"
                   "#    include <winapifamily.h>\n"
                   "#    if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) &&                  \\\n"
                   "        (!defined(WINAPI_PARTITION_SYSTEM) ||                                  \\\n"
                   "         !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_SYSTEM))\n"
                   "#      define _LIBCPP_WINDOWS_STORE_APP\n"
                   "#    endif\n"
                   "#  endif\n"
                   "#endif // defined(_WIN32)\n"
                   "\n"
                   "#ifdef __sun__\n"
                   "#  include <sys/isa_defs.h>\n"
                   "#  ifdef _LITTLE_ENDIAN\n"
                   "#    define _LIBCPP_LITTLE_ENDIAN\n"
                   "#  else\n"
                   "#    define _LIBCPP_BIG_ENDIAN\n"
                   "#  endif\n"
                   "#endif // __sun__\n"
                   "\n"
                   "#if defined(__OpenBSD__) || defined(__CloudABI__)\n"
                   "   // Certain architectures provide arc4random(). Prefer using\n"
                   "   // arc4random() over /dev/{u,}random to make it possible to obtain\n"
                   "   // random data even when using sandboxing mechanisms such as chroots,\n"
                   "   // Capsicum, etc.\n"
                   "#  define _LIBCPP_USING_ARC4_RANDOM\n"
                   "#elif defined(__Fuchsia__) || defined(__wasi__)\n"
                   "#  define _LIBCPP_USING_GETENTROPY\n"
                   "#elif defined(__native_client__)\n"
                   "   // NaCl's sandbox (which PNaCl also runs in) doesn't allow filesystem access,\n"
                   "   // including accesses to the special files under /dev. C++11's\n"
                   "   // std::random_device is instead exposed through a NaCl syscall.\n"
                   "#  define _LIBCPP_USING_NACL_RANDOM\n"
                   "#elif defined(_LIBCPP_WIN32API)\n"
                   "#  define _LIBCPP_USING_WIN32_RANDOM\n"
                   "#else\n"
                   "#  define _LIBCPP_USING_DEV_RANDOM\n"
                   "#endif\n"
                   "\n"
                   "#if !defined(_LIBCPP_LITTLE_ENDIAN) && !defined(_LIBCPP_BIG_ENDIAN)\n"
                   "#  include <endian.h>\n"
                   "#  if __BYTE_ORDER == __LITTLE_ENDIAN\n"
                   "#    define _LIBCPP_LITTLE_ENDIAN\n"
                   "#  elif __BYTE_ORDER == __BIG_ENDIAN\n"
                   "#    define _LIBCPP_BIG_ENDIAN\n"
                   "#  else  // __BYTE_ORDER == __BIG_ENDIAN\n"
                   "#    error unable to determine endian\n"
                   "#  endif\n"
                   "#endif // !defined(_LIBCPP_LITTLE_ENDIAN) && !defined(_LIBCPP_BIG_ENDIAN)\n"
                   "\n"
                   "#if __has_attribute(__no_sanitize__) && !defined(_LIBCPP_COMPILER_GCC)\n"
                   "#  define _LIBCPP_NO_CFI __attribute__((__no_sanitize__(\"cfi\")))\n"
                   "#else\n"
                   "#  define _LIBCPP_NO_CFI\n"
                   "#endif\n"
                   "\n"
                   "// If the compiler supports using_if_exists, pretend we have those functions and they'll\n"
                   "// be picked up if the C library provides them.\n"
                   "//\n"
                   "// TODO: Once we drop support for Clang 12, we can assume the compiler supports using_if_exists\n"
                   "//       for platforms that don't have a conforming C11 library, so we can drop this whole thing.\n"
                   "#if __has_attribute(using_if_exists)\n"
                   "# define _LIBCPP_HAS_TIMESPEC_GET\n"
                   "# define _LIBCPP_HAS_QUICK_EXIT\n"
                   "# define _LIBCPP_HAS_ALIGNED_ALLOC\n"
                   "#else\n"
                   "#if (defined(__ISO_C_VISIBLE) && (__ISO_C_VISIBLE >= 2011)) || __cplusplus >= 201103L\n"
                   "#  if defined(__FreeBSD__)\n"
                   "#    define _LIBCPP_HAS_ALIGNED_ALLOC\n"
                   "#    define _LIBCPP_HAS_QUICK_EXIT\n"
                   "#    if __FreeBSD_version >= 1300064 || \\\n"
                   "       (__FreeBSD_version >= 1201504 && __FreeBSD_version < 1300000)\n"
                   "#      define _LIBCPP_HAS_TIMESPEC_GET\n"
                   "#    endif\n"
                   "#  elif defined(__BIONIC__)\n"
                   "#    if __ANDROID_API__ >= 21\n"
                   "#      define _LIBCPP_HAS_QUICK_EXIT\n"
                   "#    endif\n"
                   "#    if __ANDROID_API__ >= 28\n"
                   "#      define _LIBCPP_HAS_ALIGNED_ALLOC\n"
                   "#    endif\n"
                   "#    if __ANDROID_API__ >= 29\n"
                   "#      define _LIBCPP_HAS_TIMESPEC_GET\n"
                   "#    endif\n"
                   "#  elif defined(__Fuchsia__) || defined(__wasi__) || defined(__NetBSD__)\n"
                   "#    define _LIBCPP_HAS_ALIGNED_ALLOC\n"
                   "#    define _LIBCPP_HAS_QUICK_EXIT\n"
                   "#    define _LIBCPP_HAS_TIMESPEC_GET\n"
                   "#  elif defined(__OpenBSD__)\n"
                   "#    define _LIBCPP_HAS_ALIGNED_ALLOC\n"
                   "#    define _LIBCPP_HAS_TIMESPEC_GET\n"
                   "#  elif defined(__linux__)\n"
                   "#    if !defined(_LIBCPP_HAS_MUSL_LIBC)\n"
                   "#      if _LIBCPP_GLIBC_PREREQ(2, 15) || defined(__BIONIC__)\n"
                   "#        define _LIBCPP_HAS_QUICK_EXIT\n"
                   "#      endif\n"
                   "#      if _LIBCPP_GLIBC_PREREQ(2, 17)\n"
                   "#        define _LIBCPP_HAS_ALIGNED_ALLOC\n"
                   "#        define _LIBCPP_HAS_TIMESPEC_GET\n"
                   "#      endif\n"
                   "#    else // defined(_LIBCPP_HAS_MUSL_LIBC)\n"
                   "#      define _LIBCPP_HAS_ALIGNED_ALLOC\n"
                   "#      define _LIBCPP_HAS_QUICK_EXIT\n"
                   "#      define _LIBCPP_HAS_TIMESPEC_GET\n"
                   "#    endif\n"
                   "#  elif defined(_LIBCPP_MSVCRT)\n"
                   "     // Using Microsoft's C Runtime library, not MinGW\n"
                   "#    define _LIBCPP_HAS_TIMESPEC_GET\n"
                   "#  elif defined(__APPLE__)\n"
                   "     // timespec_get and aligned_alloc were introduced in macOS 10.15 and\n"
                   "     // aligned releases\n"
                   "#    if ((defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) && __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 101500) || \\\n"
                   "         (defined(__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__) && __ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__ >= 130000) || \\\n"
                   "         (defined(__ENVIRONMENT_TV_OS_VERSION_MIN_REQUIRED__) && __ENVIRONMENT_TV_OS_VERSION_MIN_REQUIRED__ >= 130000) || \\\n"
                   "         (defined(__ENVIRONMENT_WATCH_OS_VERSION_MIN_REQUIRED__) && __ENVIRONMENT_WATCH_OS_VERSION_MIN_REQUIRED__ >= 60000))\n"
                   "#      define _LIBCPP_HAS_ALIGNED_ALLOC\n"
                   "#      define _LIBCPP_HAS_TIMESPEC_GET\n"
                   "#    endif\n"
                   "#  endif // __APPLE__\n"
                   "#endif\n"
                   "#endif // __has_attribute(using_if_exists)\n"
                   "\n"
                   "#ifndef _LIBCPP_CXX03_LANG\n"
                   "# define _LIBCPP_ALIGNOF(_Tp) alignof(_Tp)\n"
                   "#elif defined(_LIBCPP_COMPILER_CLANG_BASED)\n"
                   "# define _LIBCPP_ALIGNOF(_Tp) _Alignof(_Tp)\n"
                   "#else\n"
                   "# error \"We don't know a correct way to implement alignof(T) in C++03 outside of Clang\"\n"
                   "#endif\n"
                   "\n"
                   "#define _LIBCPP_PREFERRED_ALIGNOF(_Tp) __alignof(_Tp)\n"
                   "\n"
                   "#if defined(_LIBCPP_COMPILER_CLANG_BASED)\n"
                   "\n"
                   "#if defined(_LIBCPP_ALTERNATE_STRING_LAYOUT)\n"
                   "#  error _LIBCPP_ALTERNATE_STRING_LAYOUT is deprecated, please use _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT instead\n"
                   "#endif\n"
                   "#if defined(__APPLE__) && !defined(__i386__) && !defined(__x86_64__) &&       \\\n"
                   "    (!defined(__arm__) || __ARM_ARCH_7K__ >= 2)\n"
                   "#  define _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n"
                   "#endif\n"
                   "\n"
                   "#if defined(__APPLE__) && defined(__ENVIRONMENT_DRIVERKIT_VERSION_MIN_REQUIRED__)\n"
                   "#  define _LIBCPP_DRIVERKIT\n"
                   "#endif\n"
                   "\n"
                   "// For the DriverKit ABI, we use ABI v1 with a few ABI breaking fixes on top.\n"
                   "#if defined(_LIBCPP_DRIVERKIT)\n"
                   "#  define _LIBCPP_ABI_ALTERNATE_STRING_LAYOUT\n"
                   "#  define _LIBCPP_ABI_LIST_REMOVE_NODE_POINTER_UB\n"
                   "#  define _LIBCPP_ABI_TREE_REMOVE_NODE_POINTER_UB\n"
                   "#  define _LIBCPP_ABI_FIX_UNORDERED_NODE_POINTER_UB\n"
                   "#  define _LIBCPP_ABI_FORWARD_LIST_REMOVE_NODE_POINTER_UB\n"
                   "#endif\n"
                   "\n"
                   "#if __has_feature(cxx_alignas)\n"
                   "#  define _ALIGNAS_TYPE(x) alignas(x)\n"
                   "#  define _ALIGNAS(x) alignas(x)\n"
                   "#else\n"
                   "#  define _ALIGNAS_TYPE(x) __attribute__((__aligned__(_LIBCPP_ALIGNOF(x))))\n"
                   "#  define _ALIGNAS(x) __attribute__((__aligned__(x)))\n"
                   "#endif\n"
                   "\n"
                   "#if __cplusplus < 201103L\n"
                   "typedef __char16_t char16_t;\n"
                   "typedef __char32_t char32_t;\n"
                   "#endif";

int main()
{
  Fl::add_handler(escKeyConsumer);

  write_rc_file_to_run_dir("SF-Mono-Regular.otf");
  
  Globals::includeDirectories.emplace(
      "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1");
  Globals::includeDirectories.emplace("/Users/izmar/git/iditor/inctest");
  
  Fl::scrollbar_size(8);
  
  auto* win = new Fl_Window(500, 100, 600, 400, "iditor");

  win->begin();

  auto editor = new Editor(0, 0, win->w(), win->h());
  auto browser = new Fl_Hold_Browser(0, 0, 0, 0);
  browser->box(FL_FLAT_BOX);
  browser->color(FL_DARK3);
  browser->color2(FL_GRAY);
  browser->selection_color(FL_BLUE);
  browser->textcolor(FL_GRAY);
  browser->scrollbar_size(0);
  browser->scrollbar_width(0);
  browser->textsize(12);
  browser->clear_visible_focus();
  browser->hide();
  editor->setBrowser(browser);
  editor->text("typedef __char16_t char16_t;");
  win->add(editor);
  win->add(browser);
  win->resizable(editor);
  win->show();
  win->end();
  auto result = Fl::run();
  return result;
}
